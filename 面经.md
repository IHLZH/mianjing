# 面经总结

### 接口和抽象类的区别

- 设计目的：接口主要对类的行为进行约束，实现接口就具有了对应的行为；抽象类主要用于代码复用。强调所属关系
- 抽象类不能多继承，接口可以多实现
- 成员变量：接口中成员变量只能是静态final类型的，不能被修改且必须有初始值；抽象类中成员变量可以是任意类型，可以在子类中被重新定义或赋值
- 方法类型：
    - java8之前接口中方法均为public abstract，Java8之后可以有default，static方法，Java9之后可以包含private方法
    - 抽象类中既有抽象方法，也有非抽象方法



### 如何在Java中模拟多继承

- 接口与默认方法

    - 实现多个接口，每个接口可以定义默认方法来提供具体实现
    - 冲突处理：若多个接口有同名默认方法，需在类中重写并指定调用

- 组合

    - 将多个类的实例作为成员变量，通过委托调用他们的方法

    - ```
    class C {
        private A a = new A();
        private B b = new B();
        
        public void methodA() { a.methodA(); }
        public void methodB() { b.methodB(); }
    }
    ```



- 继承一个类，并实现多个接口

### Arraylist和Linkedlist的区别

- 线程安全：ArrayList和LinkedList都不保证线程安全
- 数据结构：ArrayList采用object数组存储，LinkedList采用双向链表存储
- 插入和删除的时间复杂度：
    - ArrayList队尾插入删除o(1)，指定位置插入删除o(n)，因为插入删除后，要进行往前后移动的操作
    - LinkedList头尾插入删除o(1)，指定位置插入删除o(n)，因为内存空间不连续，需要先移动到具体位置再插入删除
- LinkedList不支持随机元素访问，ArrayList支持（实现了RandomAccess接口）

### flutter中的三棵树，有数据刷新时，三棵树如何变化？

#### 三棵树

- Widget树
    - 作用：描述ui配置（嵌套结构）
    - 特点：轻量级，声明式结构，不可变，每次重建生成新实例（轻量，重建不消耗性能）
- Element树
    - 作用：Widget的实例化，连接可变Widget和不可变RenderObject的中间层，负责管理生命周期；
    - 特点：可复用，通过Widget.canUpdate判断是否需要更新渲染树
- RenderObject
    - 作用：处理布局，绘制，交互
    - 特点：重量级，直接操作底层渲染，生成新实例非常消耗性能

#### 数据刷新时，三棵树的变化

- 重建widget树
    - 有配置变化的widget会被重建
- 对比Element树
    - widget发生变化时，Element会检查新旧widget类型是否一致，类型一致则复用原来的Element并更新渲染树；不一致则创建新的Element树和渲染树
- 更新渲染树
    - 触发重新布局（Layout）和绘制（Paint），但仅更新变化部分。

### 安卓view的绘制流程



### 如何优化列表滑动卡顿问题？

1. 将主线程中耗时的数据处理操作放到子线程中
2. 使用viewHolder，将第一次查找到的视图放入静态的viewHolder中，以后绑定数据时直接从ViewHolder中拿到视图引用
3. 图片异步加载，使用Glide异步加载框架

### 列表的无限滑动，如何做预加载策略？如何做缓存策略

#### 预加载策略

##### 1.触发时机控制

通过`RecyclerView.OnScrollListener`检测滚动位置，当可见项接近列表末尾时，加载下一页

#### 缓存策略

##### 1.RecycleView缓存

```
recyclerView.setItemViewCacheSize(20)          // 缓存屏幕外视图
recyclerView.recycledViewPool.setMaxRecycledViews(VIEW_TYPE, 10) // 按类型复用
```

##### 2.数据缓存分层（多级缓存）

### java中类加载器有哪几种？

1. BootstrapClassLoader：启动类加载器。最顶层加载器，没有父类
2. ExtensionClassLoader：扩展类加载器
3. AppClassLoader：应用程序类加载器，面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

### 双亲委派机制

### 栈，队列，堆开发中的应用

栈：Activity栈

队列：Hanlder消息队列，线程池任务队列

堆：内存管理，jvm使用堆来管理内存

### 数组模拟栈

```
package com.example.learn2;

public class StackTest {

    private int[] stackTest;
    private final int cnt;
    private int top;

    public StackTest(int cnt){
        if(cnt < 0){
            System.out.println("cnt < 0");
        }
        this.cnt = cnt;
        this.stackTest = new int[cnt];
        this.top = -1;
    }

    public void push(int num){
        if(!isFull()){
            this.stackTest[++top] = num;
        }else{
            System.out.println("栈满");
        }
    }

    public int pop(){
        if(isEmpty()){
            System.out.println("栈空");
        }
        return this.stackTest[top--];
    }

    public int peek(){
        if(isEmpty()){
            System.out.println("栈空");
        }
        return this.stackTest[top];
    }

    public boolean isEmpty(){
        return top == -1;
    }

    public boolean isFull(){
        return top == cnt - 1;
    }
}

```



### 线程按顺序执行

Semaphore信号量：

```
package com.example.learn2;

import java.util.concurrent.Semaphore;

public class ThreadTest {

    public static Semaphore semA = new Semaphore(0);
    public static Semaphore semB = new Semaphore(0);

    public static void main(String[] args) {

        new Thread(new Runnable(

        ) {
            @Override
            public void run() {
                try {
                    semA.acquire();
                    semB.acquire();
                    System.out.println("Thread C");
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }

            }
        }).start();

        new Thread(new Runnable(

        ) {
            @Override
            public void run() {
                System.out.println("Thread B");
                semB.release();
            }
        }).start();

        new Thread(new Runnable(

        ) {
            @Override
            public void run() {
                System.out.println("Thread A");
                semA.release();
            }
        }).start();
    }
}

```

### 死锁如何产生

线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。

死锁需要哪些条件：

- 互斥条件
- 请求保持
- 不剥夺
- 循环等待

### LRU

1. **访问数据**时：
    - 若数据在缓存中（命中），将其移到访问序列的最前端
    - 若不在缓存中（未命中），从后端加载数据并插入最前端
2. **淘汰数据**时：移除访问序列最末端的数据

### 内存泄露和内存溢出（OOM）区别

内存泄漏：已分配的内存无法被正常释放

本质原因：

- 对象被意外保留引用（如静态集合、匿名内部类、未取消的监听器）
- 生命周期不一致

内存溢出：申请内存时没有足够的内存

原因：

- 一次性申请大量内存
- 内存泄漏导致可用内存不足

### 同步屏障

Hanlder中消息分为两种：同步消息，异步消息

平时使用handler发送的消息均为同步消息，想要发送异步消息，在创建Hanlder时（async传true）

```
public Handler(boolean async);
public Handler(Callback callback, boolean async);
public Handler(Looper looper, Callback callback, boolean async);
```

```
Message msg = handler.obtainMessage();
msg.setAsynchronous(true);       // 👈 设置为异步消息
handler.sendMessage(msg);
```

同步屏障就是发送了一个没有target的Message到消息队列中，通过postSyncBarrier方法发送，之后在looper的next方法中阻塞所有同步消息，只执行异步消息

```
// frameworks/base/core/java/android/os/MessageQueue.java

Message next() {
    ...
    if (msg != null && msg.target == null) {
        // 说明遇到了同步屏障
        // 跳过所有同步消息，查找最近的异步消息
    }
    ...
}

```

### volatile关键字

作用：

- 保证变量在内存中的可见性
- 防止jvm的指令重排序，在对变量进行读写操作时，会通过插入内存屏障的方式来禁止指令重排序
-

防止指令重排序：

jvm为了优化性能会对指令进行重排序

volatile可以禁止jvm指令重排序，例如单例模式

```
public class Singleton {
    private static volatile Singleton instance; // 👈 核心是 volatile

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {               // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) {       // 第二次检查
                    instance = new Singleton(); // 初始化对象
                }
            }
        }
        return instance;
    }
}
```

instance = new Singleton(); 这一操作分为三步：

1. 分配内存
2. 初始化对象
3. 将引用赋值给变量

指令重排后，可能会变为1 3 2，导致instance ≠ null，但未初始化完成，这时线程B拿到未初始化完的对象，会直接返回instance，导致报错

### 双重检查锁的作用

```
public class Singleton {
    private static volatile Singleton instance; // 👈 核心是 volatile

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {               // 避免已初始化时还加锁
            synchronized (Singleton.class) {
                if (instance == null) {       // 确保只有一个线程真正执行初始化操作 当一个线程获得锁时，其他线程可能在等待
                    instance = new Singleton(); // 初始化对象
                }
            }
        }
        return instance;
    }
}
```

### synchronized关键字的作用

synchronized用于确保某段代码在同一时刻只有一个线程执行

![执行 monitorenter 获取锁](https://oss.javaguide.cn/github/javaguide/java/concurrent/synchronized-get-lock-code-block.png)

### glide的三级缓存

活动缓存，内存缓存，磁盘缓存

### synchronized 和 volatile 有什么区别？

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

- `volatile` 关键字是线程同步的轻量级实现，所以 `volatile`性能肯定比`synchronized`关键字要好 。但是 `volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块 。
- `volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。
- `volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。

### HashMap中的红黑树

红黑树的五大特性：

1. 节点是红色或黑色
2. 根节点是黑色
3. 所有叶子节点是黑色
4. 红色节点的两个子节点都是黑色（红色节点不相邻）
5. 从任意节点到其每个子节点的所有路径包含相同数目的黑色节点（这一条保证了树的近似平衡）

链表长度大于等于8时，树化

链表长度小于等于6时，退化为链表

为什么选择红黑树，而不是其他平衡树？

A：红黑树是近似平衡，红黑树在综合性能上更有优势，（插入/删除）效率高于其他平衡树，查询效率（log）是巨大提升，完全可以接受

红黑树插入/删除操作时间复杂度为（logn） = 插入（log） + 调整（最多log）

### Kotlin 高阶拓展函数

```kotlin
fun letSimeji(){
    val simeji = Simeji(1, 2, 3)
    println(simeji.let { //执行一个表达式并将结果返回
        var x = 100;
    })

    println(simeji.run {//执行一个表达式并将结果返回
        this.a + this.b
    })

    println(simeji.apply {//执行一个表达式并返回对象本身
        this.a = 111;
    })

    println( simeji.also {//执行一个表达式并返回对象本身
        it.a = 111;
    })
}
```

```kotlin
    var str = "hello world"
var newStr = str.takeIf { str.length > 7 }?.let { str + str } ?: str
var newStr1 = str.takeUnless { str.length > 7 }?.let { str + str } ?: str
```

### 泛型：协变，逆变，类型擦除

泛型类型`Test<T>`存在以下几种形变：

- 协变 (Covariance)：因为Int是Number的子类，所以`Test<Int>`同样是`Test<Number>`的子类，可以直接转换
- 逆变(Contravariance)：跟上面相反，`Test<Number>`可以直接转换为`Test<Int>`，前置是后者的子类
- 抗变 (Invariant)：`Test<Int>`跟`Test<Number>`没半毛钱关系，无法互相转换

生产者out，消费者in：

- 使用`out`修饰的泛型不能用作函数的参数，对应类型的成员变量setter也会被限制，只能当做一个生产者使用。
- 使用`in`修饰的泛型不能用作函数的返回值，对应类型的成员变量getter也会被限制，只能当做一个消费者使用。

```
class OutText<out T>(){

}

class InText<in T>(){

}

var list : List<OutText<Any>> = ArrayList() //可以接受Any，以及Any的子类
var list2 : List<OutText<String>> = ArrayList()
list = list2

var list3 : List<InText<Any>> = ArrayList()
var list4 : List<InText<String>> = ArrayList() //可以接受Any，以及String的父类
list4 = list3
```

类型擦除：

和java中一样，和泛型相关的信息只会存在于编译阶段，在源代码编译之后，实际上并不会保留任何关于泛型类型的内容，这便是类型擦除；

编译时，会自动擦除所有类型：

```
class Test<T>(private var data: T) {
    fun test(t: T) : T {
        val tmp = data
        data = t
        return tmp
    }
}

编译时，擦除类型
class Test(private var data: Any?) {  //最后还是全部变成Any?类型了
    fun test(t: Any?) : Any? {
        val tmp = data
        data = t
        return tmp
    }
}
```

### 局部内部类和匿名内部类只能访问局部final

局部内部类和匿名内部类只能访问局部final变量的原因主要与变量的生命周期和数据一致性有关。

首先，局部内部类和匿名内部类是定义在方法内部的类，它们的生命周期与方法的执行周期不同。当方法执行完毕后，方法中的局部变量会被销毁，但内部类对象可能仍然存在。如果内部类对象访问了一个已经销毁的局部变量，就会产生问题。

为了解决这个问题，Java编译器会将局部变量复制一份作为内部类的成员变量，这样即使局部变量被销毁，内部类仍然可以访问它的副本。但是，这样做也带来了新的问题：如何保证局部变量和内部类成员变量的一致性？

为了解决这个一致性问题，Java要求局部变量必须是final的。final变量在初始化后不能再被修改，这样就保证了局部变量和内部类成员变量的一致性。

### ConcurrentHashMap原理

ConcurrentHashMap是由很多个segment组成，每个segment就是一个类似于hashMap的结构，segment的个数一旦初始化就

### 用户态，内核态

### 处理滑动冲突

外部拦截法（父容器处理）：父容器在拦截方法中根据手势方向来决定是否拦截

内部拦截发（子控件处理）：子View在需要时调用

```
getParent().requestDisallowInterceptTouchEvent(true);
```

边界传递法：子View先处理事件，当滑动到边界时再交给父容器处理（感觉就是内部拦截法）

```
@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    if (isTop() && ev.getAction() == MotionEvent.ACTION_MOVE && isPullingDown()) {
        // 通知父容器可以拦截
        getParent().requestDisallowInterceptTouchEvent(false);
    }
    return super.dispatchTouchEvent(ev);
}
```

### Glide缓存

glide缓存分三级：

1. ActiveResources弱引用缓存，用弱引用和引用计数来保证ui使用中的图片不被清理

2. MemoryCache内存缓存，LruResourceCache，基于LRU算法（最近最少使用）

3. DiskLruCacheWrapper磁盘缓存，默认250MB，Key用SHA256生成，缓存策略有：

    1. 原始数据+转换后数据
    2. 原始数据
    3. 转换后数据
    4. 不缓存
    5. 自动判断

   glide优先查活动缓存，其次内存，最后磁盘，否则走网络请求

在有内存缓存的情况下，为什么还需要有弱引用缓存呢？

答：防止当前正在显示的图片，因为LRU达到上限，图片被回收；弱引用缓存保证ui使用中的图片不被清理

### ANR

AMS和WMS会检测app的响应时间，如果app在特定时间内无法响应屏幕触摸或键盘输入事件或者特定事件没有处理完，就会出现ANR

产生原因：

1. 输入事件，5秒内无法响应屏幕触摸事件或键盘输入事件
2. Broadcast，前台（onRecevie）10秒内没有处理完，后台60秒
3. service，前台服务10秒，后台服务200秒
4. contentprovider，publish10秒内没进行完

常见场景：

1. 主线程进行耗时操作
    1. 网络请求
    2. 文件读写
    3. 数据库操作
2. ui绘制onDraw方法中执行了耗时操作
3. 死锁
4. BroadcastReceiver在onReceive里执行了耗时操作
5. Service在`onStartCommand()` 或 `onCreate()` 里做了长时间任务。
6. ContentProvider 初始化耗时

Anr分析办法：

1.  log日志
2. traces.txt

### onNewIntent

当前Activity已经存在的情况下才会被调用

当启动模式为singleTask，如果系统已经存在一个实例，这时就会调用onNewIntent方法

### Http常见字段

1. Host字段
2. Content-length回应的数据长度
3. Connection连接方式，客户端是否要求服务器使用长连接
4. Content-Type数据格式
5. Content-Encoding数据的压缩方式

### Http报文组成

请求报文：

1. 请求行
    1. 请求方法：GET，POST，PUT，DELETE等
    2. 请求url
    3. http版本：http1.1，http2
2. 请求头
    1. 客户端环境信息
    2. 各种字段host，content-length，content-type
3. 请求体
    1. 要发送给服务器的数据

响应报文：

1. 状态行
    1. http版本
    2. 状态码
    3. 状态信息
2. 响应头
    1. 服务器环境信息
    2. content-type，content-length，server，set-cookie
3. 响应体
    1. 服务器返回的数据

### 常见异常

1. 空指针异常 NullPointerException
2. 文件不存在 FileNotFind
3. 数组越界 ArrayIndexOutOfBoundsException
4. 类型转换异常 ClassCastException
5. 算数异常 ArithmeticException
6. 非法参数 IllegalArgumentException
7. 不支持操作 UnsupportedOperationException
8. 找不到类 ClassNotFoundException
9. io异常 IOException
10. sql异常 SQLException

### 线程池设计思路

先说一下线程池重要参数

1. 核心线程数：任务队列未满时，最大可同时运行的线程数量
2. 最大线程数：任务队列满了，就可以在核心线程数外再开一些线程，这时候能够开的最大线程数量
3. 任务队列：新任务到来时，会先判断核心线程数是否已满，如果满了，就把任务放到任务队列中，任务队列也满了，就开新线程，但数量不能超过最大线程数

此外还有一些参数：等待时间，拒绝策略

设计线程池需要考虑以下几个因素：

| 因素             | 说明                            |
| ---------------- | ------------------------------- |
| **任务类型**     | CPU 密集型 / IO 密集型 / 混合型 |
| **任务量**       | 任务提交频率，任务耗时          |
| **线程数**       | 核心线程数、最大线程数          |
| **队列类型**     | 有界队列 / 无界队列             |
| **线程生命周期** | 空闲线程回收策略                |
| **线程优先级**   | 前后台任务不同优先级            |
| **异常处理**     | 防止任务抛异常导致线程死亡      |

然后我们根据任务类型来设计线程池

1. CPU密集型任务
    1. 特点：计算密集，占用cpu多，io少
    2. 设计原则
        1. 核心线程数 ≈ CPU核心数
        2. 队列可以较小，避免任务堆积
2. IO密集型任务（图片加载）
    1. 特点：任务主要等待IO（网络，文件）
    2. 设计原则：
        1. 核心线程数可以 > CPU核心数，因为线程大部分时间阻塞
        2. 队列可以较大
3. 混合型任务
    1. 特点：任务既有计算也有io
    2. 设计原则：
        1. 核心线程数在CPU核心数和IO数之间折中
        2. 队列大小根据任务量调整

### 线程池类型

1. FixedThreadPool：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
2. SingleThreadExecutor：只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
3. CacheThreadPool：可缓存线程池，线程数量可伸缩，可复用空闲线程
4. ScheduledThreadPool：给定的延迟后运行任务或者定期执行任务的线程池。

### 如何定位内存泄漏

